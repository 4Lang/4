#ifndef _TOKENS_HPP_
#define _TOKENS_HPP_

#include <unordered_map>
#include <string>
#include <functional>

enum Token {
	END,
	INDENT,
	WHITESPACE,
	COMMENT,
	INT_LITERAL,
	FLT_LITERAL,
	STR_LITERAL,
	IDENTIFIER,
	EQUALS,
	DOT,
	RIGHT_ASSIGN,
	LEFT_ASSIGN,
	AND_ASSIGN,
	OR_ASSIGN,
	XOR_ASSIGN,
	SUB_ASSIGN,
	ADD_ASSIGN,
	MUL_ASSIGN,
	DIV_ASSIGN,
	MOD_ASSIGN,
	POW_ASSIGN,
	RIGHT_OP,
	LEFT_OP,
	INC_OP,
	DEC_OP,
	AND_OP,
	OR_OP,
	LE_OP,
	GE_OP,
	EQ_OP,
	NE_OP,
	TILDE,
	NOT,
	AND,
	OR,
	XOR,
	SUB,
	ADD,
	MUL,
	DIV,
	MOD,
	POW,
	LEFT,
	RIGHT,
	COMMA,
	COLON,
	LPARENT,
	RPARENT,
	LBRACKET,
	RBRACKET,
	VAR,
	IF,
	ELSE,
	ELSEIF,
	LOOP,
	SWITCH,
	CASE,
	DEFAULT,
	BREAK,
	CONTINUE,
	GOTO,
	RETURN,
	STRUCT,
	TRUE,
	FALSE,
	TRY,
	CATCH,
	FINALLY,
};

namespace std {
	template <> struct hash<Token> {
		size_t operator()(const Token &t) const {
			return static_cast<size_t>(t);
		}
	};
}

const std::string& TokenName(const Token &token) {
	
	static const std::unordered_map<Token, std::string> names = {
		{END, "EOF"},
		{INDENT, "INDENT"},
		{WHITESPACE, "WHITESPACE"},
		{COMMENT, "COMMENT"},
		{INT_LITERAL, "INT_LITERAL"},
		{FLT_LITERAL, "FLT_LITERAL"},
		{STR_LITERAL, "STR_LITERAL"},
		{IDENTIFIER, "IDENTIFIER"},
		{EQUALS, "EQUALS"},
		{DOT, "DOT"},
		{RIGHT_ASSIGN, "RIGHT_ASSIGN"},
		{LEFT_ASSIGN, "LEFT_ASSIGN"},
		{AND_ASSIGN, "AND_ASSIGN"},
		{OR_ASSIGN, "OR_ASSIGN"},
		{XOR_ASSIGN, "XOR_ASSIGN"},
		{SUB_ASSIGN, "SUB_ASSIGN"},
		{ADD_ASSIGN, "ADD_ASSIGN"},
		{MUL_ASSIGN, "MUL_ASSIGN"},
		{DIV_ASSIGN, "DIV_ASSIGN"},
		{MOD_ASSIGN, "MOD_ASSIGN"},
		{POW_ASSIGN, "POW_ASSIGN"},
		{RIGHT_OP, "RIGHT_OP"},
		{LEFT_OP, "LEFT_OP"},
		{INC_OP, "INC_OP"},
		{DEC_OP, "DEC_OP"},
		{AND_OP, "AND_OP"},
		{OR_OP, "OR_OP"},
		{LE_OP, "LE_OP"},
		{GE_OP, "GE_OP"},
		{EQ_OP, "EQ_OP"},
		{NE_OP, "NE_OP"},
		{TILDE, "TILDE"},
		{NOT, "NOT"},
		{AND, "AND"},
		{OR, "OR"},
		{XOR, "XOR"},
		{SUB, "SUB"},
		{ADD, "ADD"},
		{MUL, "MUL"},
		{DIV, "DIV"},
		{MOD, "MOD"},
		{POW, "POW"},
		{LEFT, "LEFT"},
		{RIGHT, "RIGHT"},
		{COMMA, "COMMA"},
		{COLON, "COLON"},
		{LPARENT, "LPARENT"},
		{RPARENT, "RPARENT"},
		{LBRACKET, "LBRACKET"},
		{RBRACKET, "RBRACKET"},
		{VAR, "VAR"},
		{IF, "IF"},
		{ELSE, "ELSE"},
		{ELSEIF, "ELSEIF"},
		{LOOP, "LOOP"},
		{SWITCH, "SWITCH"},
		{CASE, "CASE"},
		{DEFAULT, "DEFAULT"},
		{BREAK, "BREAK"},
		{CONTINUE, "CONTINUE"},
		{GOTO, "GOTO"},
		{RETURN, "RETURN"},
		{STRUCT, "STRUCT"},
		{TRUE, "TRUE"},
		{FALSE, "FALSE"},
		{TRY, "TRY"},
		{CATCH, "CATCH"},
		{FINALLY, "FINALLY"}
	};
	
	return names.find(token)->second;
}

#endif
